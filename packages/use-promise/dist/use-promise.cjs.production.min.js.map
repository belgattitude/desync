{"version":3,"file":"use-promise.cjs.production.min.js","sources":["../src/use-promise.ts"],"sourcesContent":["import { useCallback, useEffect, useReducer, useRef, useState } from 'react';\nimport { useDeepCompareMemoize } from '@desync/use-deep-compare-memoize';\n\nexport type QueryKey<TVariables> = TVariables;\nexport type QueryFunction<TResult, TVariables extends object> = (variables: TVariables) => Promise<TResult>;\nexport interface QueryOptions<TResult> {\n  initialData?: TResult;\n  /*\n  manual?: boolean;\n  retry?: boolean | number;\n  retryDelay?: (retryAttempt: number) => number;\n  staleTime?: number;\n  cacheTime?: number;\n  refetchInterval?: false | number;\n  refetchIntervalInBackground?: boolean;\n  refetchOnWindowFocus?: boolean;\n  onError?: (err: any) => void;\n  onSuccess?: (data: TResult) => void;\n  suspense?: boolean;\n  initialData?: TResult;\n  */\n}\n\nexport function usePromise<TResult, TVariables extends object>(\n  promise: QueryFunction<TResult, TVariables>,\n  params: QueryKey<TVariables>,\n  options?: QueryOptions<TResult>\n) {\n  const immediate = true;\n\n  const [error, setError] = useState<Error | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [data, setData] = useState<TResult | null>(options?.initialData ?? null);\n  const [force, forceUpdate] = useReducer((x: number) => x + 1, 0);\n\n  const mounted = useRef<boolean>(true);\n\n  const memoizedParams = useDeepCompareMemoize(params);\n\n  const promiseFn = useCallback(() => {\n    if (mounted.current) {\n      setLoading(true);\n      setData(null);\n      setError(null);\n    }\n    return promise(params)\n      .then(response => {\n        if (mounted.current) {\n          setData(response);\n          setLoading(false);\n        }\n      })\n      .catch(error => {\n        if (mounted.current) {\n          setError(error);\n          setLoading(false);\n        }\n      });\n    // Caution: keep exhaustive deps off here\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [promise, memoizedParams]);\n\n  useEffect(() => {\n    mounted.current = true;\n    if (immediate) {\n      promiseFn();\n    }\n    return () => {\n      // Loading cannot be safely determined here\n      // abort should be a no-op anyway\n      //abortController.abort();\n      mounted.current = false;\n    };\n  }, [force, promiseFn, immediate]);\n\n  const reload = useCallback(() => {\n    forceUpdate();\n  }, [force]);\n\n  return { data, isLoading: loading, error, reload };\n}\n"],"names":["promise","params","options","useState","error","setError","loading","setLoading","initialData","data","setData","useReducer","x","force","forceUpdate","mounted","useRef","memoizedParams","useDeepCompareMemoize","promiseFn","useCallback","current","then","response","useEffect","isLoading","reload"],"mappings":"qKAwBEA,EACAC,EACAC,WAI0BC,WAAuB,MAA1CC,OAAOC,SACgBF,YAAkB,GAAzCG,OAASC,SACQJ,qBAAyBD,MAAAA,SAAAA,EAASM,2BAAe,MAAlEC,OAAMC,SACgBC,cAAW,SAACC,UAAcA,EAAI,IAAG,GAAvDC,OAAOC,OAERC,EAAUC,UAAgB,GAE1BC,EAAiBC,wBAAsBjB,GAEvCkB,EAAYC,eAAY,kBACxBL,EAAQM,UACVd,GAAW,GACXG,EAAQ,MACRL,EAAS,OAEJL,EAAQC,GACZqB,MAAK,SAAAC,GACAR,EAAQM,UACVX,EAAQa,GACRhB,GAAW,cAGR,SAAAH,GACDW,EAAQM,UACVhB,EAASD,GACTG,GAAW,SAKhB,CAACP,EAASiB,WAEbO,aAAU,kBACRT,EAAQM,SAAU,EAEhBF,IAEK,WAILJ,EAAQM,SAAU,KAEnB,CAACR,EAAOM,GA7CO,IAmDX,CAAEV,KAAAA,EAAMgB,UAAWnB,EAASF,MAAAA,EAAOsB,OAJ3BN,eAAY,WACzBN,MACC,CAACD"}